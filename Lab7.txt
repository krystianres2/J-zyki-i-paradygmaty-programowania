(print (append '(1 2 3 4) '(a b c d)))

(defun laczenie (l1 l2)
	(let ((l3 '()))
		(dolist (item l1)
			(push item l3))
		(dolist (item l2)
			(push item l3))
		(reverse l3)
 	)
)

(defun odwrocListe (list)
  (let (( wynik '()))
    (dolist (item list)
      (push item wynik)
    )
    wynik
  )
)

(defun jestPalindromem (list)
  (let ((pomList (reverseList list)))
    (equal pomList list)
  )
)

(defun sortujListe (list)
  (dotimes (i (- (length list) 1))
    (dotimes (j (- (length list) i 1))
      (if (> (nth j list) (nth (+ j 1) list))
          (let ((temp (nth j list)))
            (setf (nth j list) (nth (+ j 1) list))
            (setf (nth (+ j 1) list) temp) 
        )
      )
    )
    )
  list)

(defun iloczynList (list1 list2)
  (let ((wynik '()))
    (if (> (length list1) (length list2))
        (dotimes (i (length list2))
          (push (* (nth i list1) (nth i list2)) wynik))
        (dotimes (i (length list1))
          (push (* (nth i list1) (nth i list2)) wynik)))
    (reverse wynik))
)

(defun zad6 (list)
  (let ((wynik 0))
    (dotimes (i (length list))
      (when (= (mod (nth i list) 3) 0)
        (incf wynik)))
  wynik))
  
(defun zad7 (list N)
  (let ((wynik 0))
    (dolist (item list)
      (if (= (mod item N) 0)
        (incf wynik)
      )
    )
  wynik)
)

(defun zad8 (stos)
  (let ((wynik '()) (liczba 0))
    (dolist (item stos)
      (setq liczba (pop stos))
      (when (= (mod liczba 5) 0)
        (push liczba wynik)
      )
    )
  wynik)
)

(defun zad9 (A B)
  (let ((wynik '()))
    (loop for i from (ceiling A) to (floor B) do
      (push i wynik)
    )
  (reverse wynik))  
)

(defun zad10 (A B)
  (let ((wynik '()))
    (loop for i from (ceiling A) to (floor B) do
      (push (code-char i) wynik)
    )
  (reverse wynik))